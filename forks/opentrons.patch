--- opentrons/hardware_control/api.py	2025-07-29 18:56:50.000000000 -0500
+++ opentrons/hardware_control/api.py	2026-01-11 00:27:38.868798593 -0600
@@ -76,6 +76,7 @@
     machine_from_deck,
 )
 
+from .backends.simulation_controller import SimulationController
 
 mod_log = logging.getLogger(__name__)
 
@@ -206,7 +207,7 @@
             checked_config = config
         else:
             checked_config = robot_configs.load_ot2()
-        backend = await Controller.build(checked_config)
+        backend = await SimulationController.build(checked_config)
         backend.set_lights(button=None, rails=False)
 
         async def blink() -> None:
--- /dev/null	2026-01-15 19:39:10.638000095 -0600
+++ opentrons/hardware_control/backends/simulation_controller.py	2026-01-11 00:27:38.869798599 -0600
@@ -0,0 +1,297 @@
+from __future__ import annotations
+import asyncio
+import logging
+from contextlib import contextmanager
+from typing import Dict, List, Optional, Any, TYPE_CHECKING, Iterator, Tuple, Sequence, Union
+from typing_extensions import Final
+
+try:
+    import aionotify  # type: ignore[import-untyped]
+except (OSError, ModuleNotFoundError):
+    aionotify = None
+
+import opentrons.config
+from opentrons_shared_data.pipette.types import PipetteName
+from opentrons.config.types import RobotConfig
+from opentrons.types import Mount
+from ..dev_types import AttachedInstruments, AttachedPipette
+from ..module_control import AttachedModulesControl
+from ..simulation import ZMQSimulationClient, AxisMapper
+from ..types import (
+    BoardRevision,
+    DoorState,
+    EstopState,
+    StatusBarState,
+    Axis,
+    AionotifyEvent,
+)
+
+if TYPE_CHECKING:
+    from opentrons_shared_data.pipette.types import PipetteModel
+    from ..dev_types import (
+        AttachedPipette,
+        AttachedInstruments,
+        InstrumentHardwareConfigs,
+    )
+    from opentrons.drivers.rpi_drivers.dev_types import GPIODriverLike
+
+MODULE_LOG = logging.getLogger(__name__)
+
+
+class SimulationController:
+    """The simulation instance of the controller for controlling
+    simulated hardware via ZMQ.
+    """
+
+    @classmethod
+    async def build(cls, config: Optional[RobotConfig]) -> SimulationController:
+        """Build a SimulationController instance.
+
+        Use this factory method rather than the initializer to handle proper
+        simulation client initialization.
+
+        :param config: A loaded robot config.
+        """
+        instance = cls(config, None)
+        await instance.connect()
+        return instance
+
+    def __init__(self, config: Optional[RobotConfig], gpio: GPIODriverLike):
+        """Build a SimulationController instance.
+
+        Always prefer using :py:meth:`.build` to create an instance of this class.
+        """
+        if not opentrons.config.IS_ROBOT:
+            MODULE_LOG.warning(
+                "This is intended to run on a robot, and while it can connect "
+                "to a smoothie via a usb/serial adapter unexpected things "
+                "using gpios (such as smoothie reset or light management) "
+                "will fail. If you are seeing this message and you are "
+                "running on a robot, you need to set the RUNNING_ON_PI "
+                "environmental variable to 1."
+            )
+
+        self.config = config or opentrons.config.robot_configs.load_ot2()
+
+        self._simulation_client = ZMQSimulationClient()
+        self._axis_mapper = AxisMapper()
+        self._board_revision: Final = BoardRevision.A
+        self._cached_fw_version: Optional[str] = "simulation-1.0.0"
+        self._module_controls: Optional[AttachedModulesControl] = None
+
+        # Minimal state tracking
+        self._door_state = DoorState.CLOSED
+        self._estop_state = EstopState.NOT_PRESENT
+
+        # No extra state tracking needed - Controller doesn't track pause state
+
+    @staticmethod
+    def _build_event_watcher() -> aionotify.Watcher:
+        """Event watcher not needed for simulation."""
+        return None
+
+    @property
+    def gpio_chardev(self) -> GPIODriverLike:
+        """Mock GPIO driver interface for simulation."""
+        return None  # type: ignore
+
+    @property
+    def board_revision(self) -> BoardRevision:
+        return self._board_revision
+
+    @property
+    def module_controls(self) -> AttachedModulesControl:
+        if not self._module_controls:
+            raise AttributeError("Module controls not found.")
+        return self._module_controls
+
+    @module_controls.setter
+    def module_controls(self, module_controls: AttachedModulesControl) -> None:
+        self._module_controls = module_controls
+
+    async def get_serial_number(self) -> Optional[str]:
+        """Get simulated robot serial number."""
+        return "SIM123456789"
+
+    def start_gpio_door_watcher(
+        self,
+        loop: asyncio.AbstractEventLoop,
+        update_door_state: Any,
+    ) -> None:
+        """Start door watcher (simulation - no-op)."""
+        pass
+
+    async def update_position(self) -> Dict[str, float]:
+        """Update position from simulation."""
+        joint_positions = await self._simulation_client.get_joint_positions()
+        return self._axis_mapper.convert_joint_positions_to_axes(joint_positions)
+
+    def _unhomed_axes(self, axes: Sequence[str]) -> List[str]:
+        """Get list of unhomed axes from sequence."""
+        homed = self._simulation_client.is_homed(list(axes))
+        return [] if homed else list(axes)
+
+    def is_homed(self, axes: Sequence[str]) -> bool:
+        """Check if all axes in sequence are homed."""
+        return self._simulation_client.is_homed(list(axes))
+
+    async def move(
+        self,
+        target_position: Dict[str, float],
+        home_flagged_axes: bool = True,
+        speed: Optional[float] = None,
+        axis_max_speeds: Optional[Dict[str, float]] = None,
+    ) -> None:
+        """Move robot axes to target positions."""
+        joint_commands = self._axis_mapper.convert_positions_to_joints(target_position)
+        if not joint_commands:
+            return
+        success = await self._simulation_client.move_joints(joint_commands)
+        if not success:
+            raise RuntimeError("Failed to execute movement in simulation")
+
+    async def home(self, axes: Optional[List[str]] = None) -> Dict[str, float]:
+        """Home specified axes or all axes."""
+        success = await self._simulation_client.home_robot()
+        if not success:
+            raise RuntimeError("Failed to home robot in simulation")
+        return await self.update_position()
+
+    async def fast_home(self, axes: Sequence[str], margin: float) -> Dict[str, float]:
+        """Fast home with margin (simulation just uses regular home)."""
+        return await self.home(list(axes))
+
+    async def _query_mount(
+        self, mount: Mount, expected: Union["PipetteModel", PipetteName, None]
+    ) -> "AttachedPipette":
+        """Query mount for attached pipette (simulation)."""
+        instruments = self._simulation_client.get_attached_instruments()
+        mount_info = instruments.get(mount.name.lower(), {})
+
+        if mount_info.get("model"):
+            return {"config": mount_info.get("config"), "id": mount_info.get("id")}
+        else:
+            if expected:
+                raise RuntimeError(
+                    f"mount {mount}: instrument {expected} was"
+                    f" requested, but no instrument is present"
+                )
+            return {"config": None, "id": None}
+
+    async def get_attached_instruments(
+        self, expected: Dict[Mount, PipetteName]
+    ) -> "AttachedInstruments":
+        """Find the instruments attached to our mounts (simulation)."""
+        return {
+            mount: await self._query_mount(mount, expected.get(mount))
+            for mount in Mount.ot2_mounts()
+        }
+
+    def set_active_current(self, axis_currents: Dict[Axis, float]) -> None:
+        """Set active current for axes (simulation - no-op)."""
+        pass
+
+    @contextmanager
+    def save_current(self) -> Iterator[None]:
+        """Save and restore current settings (simulation - no-op)."""
+        yield
+
+    async def _handle_watch_event(self) -> None:
+        pass
+
+    async def watch(self, loop: asyncio.AbstractEventLoop) -> None:
+        pass
+
+    async def connect(self, port: Optional[str] = None) -> None:
+        """Build driver and connect to it."""
+        await self._simulation_client.connect()
+        await self.update_fw_version()
+
+    @property
+    def axis_bounds(self) -> Dict[Axis, Tuple[float, float]]:
+        """The (minimum, maximum) bounds for each axis."""
+        return {
+            Axis.X: (0.0, 418.0),
+            Axis.Y: (0.0, 353.0),
+            Axis.Z: (0.0, 218.0),
+            Axis.A: (0.0, 218.0),
+            Axis.B: (0.0, 19.0),
+            Axis.C: (0.0, 19.0),
+        }
+
+    @property
+    def fw_version(self) -> Optional[str]:
+        return self._cached_fw_version
+
+    async def update_fw_version(self) -> None:
+        """Update firmware version (simulation)."""
+        self._cached_fw_version = "simulation-1.0.0"
+
+    async def update_firmware(
+        self, filename: str, loop: asyncio.AbstractEventLoop, modeset: bool
+    ) -> str:
+        """Simulate firmware update."""
+        await self.update_fw_version()
+        return f"Simulated firmware update with {filename} completed"
+
+    def engaged_axes(self) -> Dict[str, bool]:
+        """Get engagement status of all axes."""
+        return {"X": True, "Y": True, "Z": True, "A": True, "B": True, "C": True}
+
+    async def disengage_axes(self, axes: List[str]) -> None:
+        """Disengage specified axes (simulation - no-op)."""
+        pass
+
+    def set_lights(self, button: Optional[bool], rails: Optional[bool]) -> None:
+        """Set lights via simulation."""
+        # Controller calls gpio_chardev.set_*_light() directly
+        # For simulation, we call Isaac Sim directly
+        if button is not None:
+            self._simulation_client.set_button_light(button)
+
+        if rails is not None:
+            self._simulation_client.set_rail_lights(rails)
+
+    def get_lights(self) -> Dict[str, bool]:
+        """Get light status from simulation."""
+        # Controller calls gpio_chardev.get_*_light() directly
+        # For simulation, we query Isaac Sim directly
+        return self._simulation_client.get_lights()
+
+    def pause(self) -> None:
+        """Pause robot movement."""
+        # Controller calls smoothie_driver.pause() directly
+        # For simulation, we call Isaac Sim directly
+        self._simulation_client.pause_robot()
+
+    def resume(self) -> None:
+        """Resume robot movement."""
+        # Controller calls smoothie_driver.resume() directly
+        # For simulation, we call Isaac Sim directly
+        self._simulation_client.resume_robot()
+
+    async def halt(self) -> None:
+        """Halt robot movement."""
+        # Controller calls smoothie_driver.kill() directly
+        # For simulation, send halt command to Isaac Sim
+        await self._simulation_client.halt_robot()
+
+    async def hard_halt(self) -> None:
+        """Hard halt robot movement."""
+        # Hard halt is same as regular halt for physics simulation
+        await self.halt()
+
+    async def probe(self, axis: str, distance: float) -> Dict[str, float]:
+        """Run a probe and return the new position dict."""
+        return self._simulation_client.probe_axis(axis, distance)
+
+    async def clean_up(self) -> None:
+        """Clean up simulation resources."""
+        if hasattr(self, "_simulation_client"):
+            await self._simulation_client.disconnect()
+
+    async def configure_mount(
+        self, mount: Mount, config: "InstrumentHardwareConfigs"
+    ) -> None:
+        """Configure mount with instrument hardware settings (simulation - no-op)."""
+        pass
--- /dev/null	2026-01-15 19:39:10.638000095 -0600
+++ opentrons/hardware_control/simulation/__init__.py	2026-01-11 00:27:38.873798620 -0600
@@ -0,0 +1,14 @@
+"""
+Simulation infrastructure for Opentrons hardware control.
+
+This module provides ZMQ-based simulation backends that redirect hardware
+commands to external physics simulations instead of real robot hardware.
+"""
+
+from .zmq_client import ZMQSimulationClient
+from .axis_mapper import AxisMapper
+
+__all__ = [
+    "ZMQSimulationClient",
+    "AxisMapper",
+]
\ No newline at end of file
--- /dev/null	2026-01-15 19:39:10.638000095 -0600
+++ opentrons/hardware_control/simulation/zmq_client.py	2026-01-11 00:27:38.873798620 -0600
@@ -0,0 +1,192 @@
+"""
+ZMQ client for communicating with external physics simulation.
+"""
+
+import json
+import logging
+import os
+from typing import Dict, List, Optional, Any
+import zmq
+
+logger = logging.getLogger(__name__)
+
+
+class ZMQSimulationClient:
+    """Client for communicating with ZMQ-based physics simulation."""
+
+    def __init__(self, server_url: Optional[str] = None):
+        """Initialize ZMQ client and connect immediately.
+
+        Args:
+            server_url: URL of simulation server. If None, uses environment variable
+                       OT2_SIMULATION_SERVER or defaults to tcp://localhost:5556
+        """
+        self.server_url = (
+            server_url or
+            os.environ.get("OT2_SIMULATION_SERVER", "tcp://localhost:5556")
+        )
+        self.context = zmq.Context()
+        self.socket = self.context.socket(zmq.REQ)
+        self.socket.connect(self.server_url)
+
+        # Set timeout for recv operations
+        self.socket.setsockopt(zmq.RCVTIMEO, 10000)  # 10 second timeout
+
+        logger.info(f"Connected to OT-2 simulation server at {self.server_url}")
+
+    async def connect(self) -> None:
+        """Connect is a no-op since we connect in __init__."""
+        pass
+
+    async def disconnect(self) -> None:
+        """Disconnect from the simulation server."""
+        if self.socket:
+            self.socket.close()
+            self.socket = None
+
+        if self.context:
+            self.context.term()
+            self.context = None
+
+        logger.info("Disconnected from OT-2 simulation server")
+
+    def _send_command(self, command: Dict[str, Any]) -> Dict[str, Any]:
+        """Send a command to the simulation server and get response.
+
+        Args:
+            command: Command dictionary to send
+
+        Returns:
+            Response dictionary from server
+
+        Raises:
+            RuntimeError: If communication fails
+        """
+        try:
+            # Send command
+            message = json.dumps(command)
+            self.socket.send_string(message)
+
+            # Wait for response
+            response_str = self.socket.recv_string()
+            response = json.loads(response_str)
+
+            logger.debug(f"Sent: {command}, Received: {response}")
+
+            return response
+
+        except zmq.Again:
+            raise RuntimeError("Simulation server response timeout")
+        except json.JSONDecodeError as e:
+            raise RuntimeError(f"Invalid JSON response from server: {e}")
+        except Exception as e:
+            raise RuntimeError(f"Communication error: {e}")
+
+    async def move_joints(self, joint_commands: List[Dict[str, Any]]) -> bool:
+        """Move multiple joints simultaneously."""
+        command = {
+            "action": "move_joints",
+            "joint_commands": joint_commands,
+        }
+
+        response = self._send_command(command)
+        return response.get("status") == "success"
+
+    async def get_joint_positions(self) -> Dict[str, float]:
+        """Get current joint positions."""
+        command = {"action": "get_joints"}
+        response = self._send_command(command)
+
+        if response.get("status") == "success":
+            return response.get("joint_positions", {})
+        else:
+            raise RuntimeError(f"Failed to get joint positions: {response}")
+
+    async def home_robot(self) -> bool:
+        """Home all robot joints."""
+        command = {"action": "home"}
+        response = self._send_command(command)
+        return response.get("status") == "success"
+
+    def is_homed(self, axes: List[str]) -> bool:
+        """Check if specified axes are homed."""
+        command = {
+            "action": "is_homed",
+            "axes": axes,
+        }
+        response = self._send_command(command)
+
+        if response.get("status") == "success":
+            return response.get("homed", False)
+        else:
+            raise RuntimeError(f"Failed to check homed status: {response}")
+
+    def probe_axis(self, axis: str, distance: float) -> Dict[str, float]:
+        """Run a probe on specified axis."""
+        command = {
+            "action": "probe",
+            "axis": axis,
+            "distance": distance,
+        }
+        response = self._send_command(command)
+
+        if response.get("status") == "success":
+            return response.get("position", {})
+        else:
+            raise RuntimeError(f"Failed to probe axis {axis}: {response}")
+
+    def get_attached_instruments(self) -> Dict[str, Any]:
+        """Get attached instruments from simulation."""
+        command = {"action": "get_attached_instruments"}
+        response = self._send_command(command)
+
+        if response.get("status") == "success":
+            return response.get("instruments", {})
+        else:
+            raise RuntimeError(f"Failed to get attached instruments: {response}")
+
+    def set_button_light(self, state: bool) -> bool:
+        """Set button light state in simulation."""
+        command = {
+            "action": "set_button_light",
+            "state": state,
+        }
+        response = self._send_command(command)
+        return response.get("status") == "success"
+
+    def set_rail_lights(self, state: bool) -> bool:
+        """Set rail lights state in simulation."""
+        command = {
+            "action": "set_rail_lights",
+            "state": state,
+        }
+        response = self._send_command(command)
+        return response.get("status") == "success"
+
+    def get_lights(self) -> Dict[str, bool]:
+        """Get current light states from simulation."""
+        command = {"action": "get_lights"}
+        response = self._send_command(command)
+
+        if response.get("status") == "success":
+            return response.get("lights", {"button": False, "rails": False})
+        else:
+            raise RuntimeError(f"Failed to get lights: {response}")
+
+    def pause_robot(self) -> bool:
+        """Pause current robot movement."""
+        command = {"action": "pause"}
+        response = self._send_command(command)
+        return response.get("status") == "success"
+
+    def resume_robot(self) -> bool:
+        """Resume paused robot movement."""
+        command = {"action": "resume"}
+        response = self._send_command(command)
+        return response.get("status") == "success"
+
+    async def halt_robot(self) -> bool:
+        """Stop current robot movement."""
+        command = {"action": "halt"}
+        response = self._send_command(command)
+        return response.get("status") == "success"
--- /dev/null	2026-01-15 19:39:10.638000095 -0600
+++ opentrons/hardware_control/simulation/axis_mapper.py	2026-01-11 00:27:38.873798620 -0600
@@ -0,0 +1,244 @@
+"""
+Axis mapping between Opentrons hardware axes and simulation joints.
+"""
+
+import logging
+from typing import Dict, List, Any
+from opentrons.types import Mount
+
+logger = logging.getLogger(__name__)
+
+
+class AxisMapper:
+    """Maps Opentrons hardware axes to simulation joint commands."""
+
+    # Mapping from Opentrons axis names to simulation joints
+    AXIS_TO_JOINT_MAPPING = {
+        "X": "pipette_casing_joint",    # X-axis gantry movement (0-418mm)
+        "Y": "pipette_rail_joint",      # Y-axis gantry movement (0-353mm)
+        "Z": "pipette_left_joint",      # Left mount Z-axis (0-218mm)
+        "A": "pipette_right_joint",     # Right mount Z-axis (0-218mm)
+        "B": "left_plunger_joint",      # Left mount plunger (0-19mm)
+        "C": "right_plunger_joint",     # Right mount plunger (0-19mm)
+    }
+
+    # Joint limits in meters (matching your joint descriptions)
+    JOINT_LIMITS = {
+        "pipette_rail_joint": (0.0, 0.353),       # Y-axis
+        "pipette_casing_joint": (0.0, 0.418),     # X-axis
+        "pipette_left_joint": (-0.218, 0.0),      # Left Z (inverted)
+        "pipette_right_joint": (-0.218, 0.0),     # Right Z (inverted)
+        "left_plunger_joint": (0.0, 0.019),       # Left plunger
+        "right_plunger_joint": (0.0, 0.019),      # Right plunger
+    }
+
+    # Opentrons home positions in mm
+    OPENTRONS_HOME_POSITIONS = {
+        "X": 418.0,    # X-axis home (right)
+        "Y": 353.0,    # Y-axis home (back)
+        "Z": 218.0,    # Left Z home (top)
+        "A": 218.0,    # Right Z home (top)
+        "B": 19.0,     # Left plunger home
+        "C": 19.0,     # Right plunger home
+    }
+
+    def __init__(self):
+        """Initialize the axis mapper."""
+        self.current_positions = {}  # Track current positions
+
+    def convert_positions_to_joints(self, target_positions: Dict[str, float]) -> List[Dict[str, Any]]:
+        """Convert Opentrons axis positions to joint commands.
+
+        Args:
+            target_positions: Dictionary mapping axis names to positions in mm
+
+        Returns:
+            List of joint command dictionaries for simulation
+        """
+        joint_commands = []
+
+        for axis_name, position_mm in target_positions.items():
+            if axis_name not in self.AXIS_TO_JOINT_MAPPING:
+                logger.warning(f"Unknown axis: {axis_name}")
+                continue
+
+            joint_name = self.AXIS_TO_JOINT_MAPPING[axis_name]
+            joint_position = self._convert_axis_to_joint_position(axis_name, position_mm)
+
+            # Validate joint limits
+            if joint_name in self.JOINT_LIMITS:
+                min_pos, max_pos = self.JOINT_LIMITS[joint_name]
+                if joint_position < min_pos or joint_position > max_pos:
+                    logger.error(
+                        f"Joint position {joint_position:.4f} out of bounds for {joint_name} "
+                        f"[{min_pos}, {max_pos}]"
+                    )
+                    continue
+
+            joint_commands.append({
+                "joint": joint_name,
+                "target_position": joint_position
+            })
+
+            # Update tracked position
+            self.current_positions[axis_name] = position_mm
+
+        return joint_commands
+
+    def _convert_axis_to_joint_position(self, axis_name: str, position_mm: float) -> float:
+        """Convert a single axis position to joint position.
+
+        Args:
+            axis_name: Opentrons axis name (X, Y, Z, A, B, C)
+            position_mm: Position in millimeters
+
+        Returns:
+            Joint position in meters
+        """
+        position_m = position_mm / 1000.0  # Convert to meters
+
+        if axis_name == "X":
+            # X-axis: 0-418mm maps to 0-0.418m joint range
+            return position_m
+
+        elif axis_name == "Y":
+            # Y-axis: 0-353mm maps to 0-0.353m joint range
+            return position_m
+
+        elif axis_name in ["Z", "A"]:
+            # Z-axes: Opentrons coordinates are inverted from joint coordinates
+            # Opentrons: 0mm (bottom) to 218mm (top/home)
+            # Joint: 0m (home/top) to -0.218m (bottom)
+            return -position_m
+
+        elif axis_name in ["B", "C"]:
+            # Plunger axes: 0-19mm maps to 0-0.019m joint range
+            return position_m
+
+        else:
+            logger.warning(f"Unknown axis conversion: {axis_name}")
+            return position_m
+
+    def get_home_joint_commands(self) -> List[Dict[str, Any]]:
+        """Get joint commands to move robot to home position.
+
+        Returns:
+            List of joint commands for homing
+        """
+        return self.convert_positions_to_joints(self.OPENTRONS_HOME_POSITIONS)
+
+    def mount_to_axis_mapping(self, mount: Mount) -> Dict[str, str]:
+        """Get axis mappings for a specific mount.
+
+        Args:
+            mount: Mount object (LEFT or RIGHT)
+
+        Returns:
+            Dictionary mapping axis types to axis names for this mount
+        """
+        if mount == Mount.LEFT:
+            return {
+                "z_axis": "Z",
+                "plunger_axis": "B"
+            }
+        else:  # Mount.RIGHT
+            return {
+                "z_axis": "A",
+                "plunger_axis": "C"
+            }
+
+    def get_mount_axis_position(self, mount: Mount, axis_type: str) -> float:
+        """Get current position of a mount's axis.
+
+        Args:
+            mount: Mount object
+            axis_type: Type of axis ("z_axis" or "plunger_axis")
+
+        Returns:
+            Current position in mm, or home position if unknown
+        """
+        axis_mapping = self.mount_to_axis_mapping(mount)
+        axis_name = axis_mapping.get(axis_type)
+
+        if axis_name:
+            return self.current_positions.get(
+                axis_name,
+                self.OPENTRONS_HOME_POSITIONS[axis_name]
+            )
+
+        return 0.0
+
+    def get_axis_name_for_mount(self, mount: Mount, axis_type: str) -> str:
+        """Get the axis name for a mount and axis type.
+
+        Args:
+            mount: Mount object
+            axis_type: Type of axis ("z_axis" or "plunger_axis")
+
+        Returns:
+            Axis name string
+        """
+        axis_mapping = self.mount_to_axis_mapping(mount)
+        return axis_mapping.get(axis_type, "")
+
+    def convert_joint_positions_to_axes(self, joint_positions: Dict[str, float]) -> Dict[str, float]:
+        """Convert joint positions back to Opentrons axis positions.
+
+        Args:
+            joint_positions: Dictionary mapping joint names to positions in meters
+
+        Returns:
+            Dictionary mapping axis names to positions in mm
+        """
+        axis_positions = {}
+
+        # Reverse mapping from joint names to axis names
+        JOINT_TO_AXIS_MAPPING = {v: k for k, v in self.AXIS_TO_JOINT_MAPPING.items()}
+
+        for joint_name, position_m in joint_positions.items():
+            if joint_name not in JOINT_TO_AXIS_MAPPING:
+                logger.warning(f"Unknown joint: {joint_name}")
+                continue
+
+            axis_name = JOINT_TO_AXIS_MAPPING[joint_name]
+            axis_position = self._convert_joint_to_axis_position(axis_name, position_m)
+            axis_positions[axis_name] = axis_position
+
+            # Update tracked position
+            self.current_positions[axis_name] = axis_position
+
+        return axis_positions
+
+    def _convert_joint_to_axis_position(self, axis_name: str, position_m: float) -> float:
+        """Convert a single joint position to axis position.
+
+        Args:
+            axis_name: Opentrons axis name (X, Y, Z, A, B, C)
+            position_m: Position in meters
+
+        Returns:
+            Axis position in millimeters
+        """
+        position_mm = position_m * 1000.0  # Convert to millimeters
+
+        if axis_name == "X":
+            # X-axis: 0-0.418m joint range maps to 0-418mm
+            return position_mm
+
+        elif axis_name == "Y":
+            # Y-axis: 0-0.353m joint range maps to 0-353mm
+            return position_mm
+
+        elif axis_name in ["Z", "A"]:
+            # Z-axes: Joint coordinates are inverted from Opentrons coordinates
+            # Joint: 0m (home/top) to -0.218m (bottom)
+            # Opentrons: 218mm (top/home) to 0mm (bottom)
+            return -position_mm
+
+        elif axis_name in ["B", "C"]:
+            # Plunger axes: 0-0.019m joint range maps to 0-19mm
+            return position_mm
+
+        else:
+            logger.warning(f"Unknown axis conversion: {axis_name}")
+            return position_mm
\ No newline at end of file
